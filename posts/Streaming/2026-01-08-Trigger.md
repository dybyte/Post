---
toc: true
title: "Streaming System Trigger"
---
# Streaming System Trigger

## 배치 vs 스트리밍

배치 시스템은 유한하고 이미 수집이 끝난 데이터를 대상으로 한 번에 처리하고, 스트리밍 시스템은 끝이 없는 데이터 흐름을 대상으로 지속적으로 처리한다.

배치는 이미 데이터가 완결된 집합이므로 워터마크를 필요로 하지 않는다.

## 기존 배치 처리 시스템

파이프라인이 입력 값을 중간 과정에서 누적하며, 마지막에 집계된 결과를 구체화해 출력한다.

입력을 모두 다 볼 때까지 중간 상태를 누적하고, 그 후에 단일 결과를 출력한다.

무한 데이터를 처리하는 것이 목적이라면 이런 식의 고전 배치 처리로는 충분하지 않다.

# Trigger

> 스트리밍 시스템에서 어떤 외부 신호로 윈도우가 출력되는 시점을 선언하는 방법이다. 즉, 결과가 생성되는 시점
> 


## 반복 업데이트 트리거

> 이 트리거는 값이 변함에 따라 주기적으로 윈도우를 위해 업데이트된 패널을 생성한다.
> 

스트리밍 시스템에서 가장 빈번하게 만날 수 있는 트리거.


경우에 따라 새 입력 데이터를 만들어낼 때마다 계산을 업데이트할 필요는 없다. 대신 초 단위나 분 단위처럼 일정 처리 시간 동안 기다렸다가 업데이트해도 충분하다.

### 정렬 지연

> 윈도우 전반에 걸쳐 고정된 영역으로 처리 시간이 나뉜다
> 

모든 윈도우에서 동시에 정기적으로 업데이트가 발생한다. 모든 업데이트가 한 번에 일어나기 때문에 적절한 부하 처리를 위해 더 큰 최대치를 다룰 수 있도록 프로비저닝이 필요하다.

### 비정렬 지연

> 한 윈도우 안에서 관찰된 데이터를 기준으로 지연된다
> 

시스템 부하를 고르게 분산시킨다는 점에서 대규모 처리를 위해 더 좋은 선택이라고 볼 수 있다.

<aside>
💡

반복 업데이트 트리거는 언제 결과의 정확성이 달성되는지에 대한 기준 없이 정확한 쪽으로 수렴한다는 사실만으로 충분하고 결과가 주기적으로 업데이트 되기를 원할 때 매우 유용하다.(입력 완결성은 별개)

</aside>

## 완료 트리거

> 이 트리거는 윈도우 내 입력이 일정 기준 완료됐다고 믿는 시점 이후에 윈도우를 위한 패널(윈도우별로 생성되는 각 출력)을 생성한다.
> 

고전 배치 처리에 더욱 가까운 형태로 스트리밍 처리를 가능하게 해준다. 누락되거나 지연된 데이터에 대한 고려가 가능하도록 해준다는 장점이 있다.


# watermark

> 워터마크는 스트리밍 시스템에서 이벤트 시간을 기준으로
특정 시점 이전의 이벤트가 더 이상 도착하지 않을 것이라고 시스템이 추정하는 기준 시각이다.
> 

이벤트 시간과 처리 시간의 차이(지연 시간)에서 오는 간극을 메우기 위해서이다. 배치 시스템에서는 유한 데이터를 처리하므로 데이터가 모두 도착했는지 판단할 수 있지만, 스트리밍 시스템에서는 데이터가 무한하다는 점과 지연 시간이 어느정도가 될 지 알 수 없다는 점 때문에 어느 시점에서 완결성을 판단할지 알 수가 없다. 따라서 워터마크가 필요하다.


### 완벽한 워터마크

입력 데이터를 완벽하게 이해한 경우. 지연 데이터가 존재하지 않음

### 휴리스틱 워터마크

입력에 대해 모든 가능한 정보를 고려해 최대한 정확한 진행 상황을 추정하는 것이다.

추정일 뿐이므로 너무 늦게 들어온 데이터가 누락될 수 있다

## 워터마크의 단점

> 사실상 완결성의 개념을 사용하는 모든 경우의 단점이다.
> 

### 너무 느림

결과를 내는 기준이 워터마크의 진행 정도에만 의존하고 있다면 출력에 직접적으로 지연이 발생한다.

→ 입력이 진행되면서 다듬어진 결과가 보이고 종국에는 완벽해지는 것이 더 나을 것이다.

### 너무 성급함

휴리스틱 워터마크가 오판으로 실제 기다려야 하는 것보다 먼저 진행된다면, 워터마크 이전의 이벤트 시간을 갖는 데이터가 뒤늦게 도착할 수도 있다.(휴리스틱은 언제든지 틀릴 수 있다)

완결성에만 의존하는 시스템에서는 낮은 지연과 정확성을 동시에 갖추는 것은 불가능하다. 양쪽에서 최선을 취하는 방법은 무엇일까?

# 조기/정시/지연 트리거

많은 경우, 두가지 트리거 중 하나만으로는 충분한 결과를 가져오지 못하지만 둘을 결합한다면 이야기가 달라진다.

워터마크 트리거의 앞뒤로 반복 업데이트 트리거를 도입해보자.

- 생략 가능한 조기 패널: 워터마크가 윈도우 끝을 지나기 전에 주기적으로 작동하는 반복 업데이트 트리거의 결과물이다. 입력 데이터가 도착하면서 시간에 따라 윈도우가 변하는 모습을 관찰할 수 있게 해준다. 이는 워터마크가 너무 느려질 수 있는 단점을 보완해준다.
- 단일 정시 패널: 완료 트리거가 윈도우 끝을 통과한 후에 동작하는 결과물이다.
- 생략 가능한 지연 패널: 워터마크가 윈도우 끝을 통과한 후에 주기적으로 트리거되는 반복 업데이트 트리거의 결과물이다.( 완벽한 워터마크의 경우 지연 패널은 의미가 없다.) 이는 너무 성급하게 동작하는 워터마크의 단점을 보완해준다.

→ 완료 트리거(워터마크 트리거)를 사용하기 때문에 완결성에 대한 판단을 내릴 수 있고, 반복 업데이트 트리거를 사용한 결과와 매우 흡사하다. 지연 트리거 덕분에 데이터 누락을 보다 잘 감지할 수 있다.
